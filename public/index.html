<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Advanced Professional Trading AI - Smart Money Concepts</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg,#0f172a 0%,#1e293b 100%);
      color:#f8fafc; line-height:1.6; min-height:100vh;
    }
    .container { max-width:1200px; margin:0 auto; padding:15px; }
    header { background:rgba(30,41,59,0.9); padding:15px 0; border-bottom:1px solid rgba(255,255,255,0.08); }
    .header-content { display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap; }
    .logo h1 { font-size:1.4rem; background:linear-gradient(90deg,#3b82f6,#10b981); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; }
    .btn { padding:8px 14px; border-radius:6px; border:0; font-weight:600; cursor:pointer; transition:all .15s; font-size:0.9rem; }
    .btn-primary { background:#3b82f6; color:#fff; } .btn-success { background:#10b981; color:#fff; }
    .btn-danger { background:#ef4444; color:#fff; } .btn-warning { background:#f59e0b; color:#fff; }
    select { padding:8px; border-radius:6px; background:#0f1724; color:#f8fafc; border:1px solid #374151; }
    .card { background:rgba(30,41,59,0.75); border-radius:10px; padding:16px; margin-bottom:18px; border:1px solid rgba(255,255,255,0.04); }
    .card-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; border-bottom:1px solid rgba(255,255,255,0.06); padding-bottom:8px; }
    .card-title { font-size:1.05rem; font-weight:600; }
    .predictions-grid { display:grid; grid-template-columns:repeat(5,1fr); gap:10px; }
    @media (max-width:1200px){ .predictions-grid{grid-template-columns:repeat(3,1fr);} }
    @media (max-width:768px){ .predictions-grid{grid-template-columns:repeat(2,1fr);} }
    @media (max-width:480px){ .predictions-grid{grid-template-columns:1fr;} }
    .prediction-card { background:rgba(8,12,20,0.7); padding:12px; border-radius:8px; border-left:4px solid #64748b; }
    .prediction-card.buy{ border-left-color:#10b981; background:rgba(16,185,129,0.08); }
    .prediction-card.sell{ border-left-color:#ef4444; background:rgba(239,68,68,0.08); }
    .prediction-header{ display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
    .prediction-type{ font-weight:700; font-size:1rem; }
    .prediction-confidence{ font-size:0.78rem; background:rgba(255,255,255,0.06); padding:3px 8px; border-radius:14px; }
    .prediction-price{ font-size:1.05rem; font-weight:700; margin:6px 0; }
    .prediction-details{ color:#94a3b8; font-size:0.85rem; margin-bottom:8px; }
    .adaptive-indicators { display:flex; gap:6px; flex-wrap:wrap; margin-top:8px; }
    .indicator-tag { background:rgba(59,130,246,0.12); color:#3b82f6; padding:3px 8px; border-radius:12px; font-size:0.75rem; }
    .progress-bar{ height:6px; background:rgba(255,255,255,0.06); border-radius:3px; overflow:hidden; }
    .progress-fill{ height:100%; background:#3b82f6; transition:width .25s; width:0%; }
    .loading{ text-align:center; padding:18px; color:#94a3b8; }
    .pulse{ animation:pulse 1.5s infinite; }
    @keyframes pulse{ 0%{opacity:1}50%{opacity:.5}100%{opacity:1} }
    .analysis-card{ background:rgba(8,12,20,0.5); padding:10px; border-radius:8px; margin-bottom:8px; }
    .risk-killswitch{ background:rgba(239,68,68,0.12); border-left:4px solid #ef4444; padding:8px; border-radius:6px; margin-top:8px; }
    .tabs{ display:flex; gap:10px; border-bottom:1px solid rgba(255,255,255,0.06); margin-bottom:12px; padding-bottom:6px; }
    .tab{ padding:8px 12px; cursor:pointer; border-bottom:2px solid transparent; color:#cbd5e1; }
    .tab.active{ color:#3b82f6; border-bottom-color:#3b82f6; }
    .tab-content{ display:none; }
    .tab-content.active{ display:block; }
    .status-badge{ padding:4px 8px; border-radius:12px; font-size:0.75rem; font-weight:600; }
    .status-success{ background:rgba(16,185,129,0.12); color:#10b981; }
    .status-fail{ background:rgba(239,68,68,0.12); color:#ef4444; }
    .input-small{ padding:6px 8px; border-radius:6px; background:#0f1724; border:1px solid #374151; color:#fff; width:80px; }
    footer{ text-align:center; color:#94a3b8; font-size:0.85rem; margin-top:18px; }
  </style>
</head>
<body>
  <header>
    <div class="container">
      <div class="header-content">
        <div class="logo"><h1>ðŸš€ Advanced Pro Trading AI - Smart Money Concepts</h1></div>
        <div class="controls">
          <select id="symbolSelect">
            <option value="BTCUSDT">BTC/USDT</option>
            <option value="ETHUSDT">ETH/USDT</option>
            <option value="BNBUSDT">BNB/USDT</option>
            <option value="ADAUSDT">ADA/USDT</option>
          </select>
          <select id="timeframeSelect">
            <option value="1m">1 Minute</option>
            <option value="5m">5 Minutes</option>
            <option value="15m">15 Minutes</option>
            <option value="1h">1 Hour</option>
          </select>
          <button id="startBtn" class="btn btn-primary">Generate Smart Predictions</button>
          <button id="backtestBtn" class="btn btn-success">Run Backtest</button>
          <button id="killSwitchBtn" class="btn btn-danger">Kill Switch</button>
        </div>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="tabs">
      <div class="tab active" data-tab="dashboard">Dashboard</div>
      <div class="tab" data-tab="history">History</div>
      <div class="tab" data-tab="performance">Performance</div>
      <div class="tab" data-tab="smc">SMC Analysis</div>
    </div>

    <section id="dashboardTab" class="tab-content active">
      <div class="card">
        <div class="card-header">
          <div class="card-title">Live Market Data</div>
          <div id="connectionStatus" style="color:#94a3b8">Connecting...</div>
        </div>
        <div id="livePrice" style="font-weight:700; font-size:1.1rem; padding:10px; background:rgba(255,255,255,0.02); border-radius:8px;">Loading price...</div>
      </div>

      <div class="card">
        <div class="card-header">
          <div class="card-title">Smart Money Concept Predictions</div>
          <div id="lastUpdate" style="color:#94a3b8">Idle</div>
        </div>

        <div id="predictionContainer">
          <div class="loading"><div class="pulse">Click "Generate Smart Predictions" to start</div></div>
        </div>

        <div style="margin-top:10px">
          <div class="progress-bar"><div id="analysisProgress" class="progress-fill"></div></div>
          <div id="progressText" style="text-align:center; color:#94a3b8; margin-top:6px; font-size:0.85rem;">SMC Analysis progress: 0%</div>
        </div>
      </div>

      <div class="card">
        <div class="card-header"><div class="card-title">Risk Management</div></div>
        <div id="riskContent"><div class="loading"><div class="pulse">Risk details will appear here</div></div></div>
      </div>
    </section>

    <section id="smcTab" class="tab-content">
      <div class="card">
        <div class="card-header"><div class="card-title">SMC Analysis</div></div>
        <div id="smcContainer"><div class="loading"><div class="pulse">SMC analysis will appear after generation</div></div></div>
      </div>
    </section>

    <section id="historyTab" class="tab-content">
      <div class="card">
        <div class="card-header">
          <div class="card-title">Prediction & Trade History</div>
          <div><button id="clearHistoryBtn" class="btn btn-warning">Clear History</button></div>
        </div>
        <div id="historyContainer"><div class="loading"><div class="pulse">No history yet</div></div></div>
      </div>
    </section>

    <section id="performanceTab" class="tab-content">
      <div class="card">
        <div class="card-header"><div class="card-title">Performance Analytics</div></div>
        <div id="performanceContainer"><div class="loading"><div class="pulse">Performance will appear after backtest / rated trades</div></div></div>
      </div>
    </section>
  </main>

  <footer class="container">Prototype â€” Paper trading only. Do not use live keys in the client.</footer>

  <script>
    // Single-file app with improvements:
    // - Orderbook-based spread via proxy
    // - IndexedDB persistence for history & settings
    // - Proper kill switch, cleared intervals, better spread guard
    // - Paper execution with simple orderbook-aware slippage model
    (function () {
      // ---- IndexedDB simple wrapper ----
      const DB = {
        name: 'smc_trading_db',
        version: 1,
        db: null,
        open() {
          return new Promise((res, rej) => {
            if (this.db) return res(this.db);
            const r = indexedDB.open(this.name, this.version);
            r.onerror = () => rej(r.error);
            r.onupgradeneeded = () => {
              const d = r.result;
              if (!d.objectStoreNames.contains('history')) d.createObjectStore('history', { keyPath: 'id' });
              if (!d.objectStoreNames.contains('batches')) d.createObjectStore('batches', { keyPath: 'id' });
              if (!d.objectStoreNames.contains('settings')) d.createObjectStore('settings', { keyPath: 'key' });
            };
            r.onsuccess = () => { this.db = r.result; res(this.db); };
          });
        },
        put(store, value) {
          return this.open().then(db => new Promise((res, rej) => {
            const tx = db.transaction(store, 'readwrite'); const st = tx.objectStore(store);
            const req = st.put(value);
            req.onsuccess = () => res(req.result);
            req.onerror = () => rej(req.error);
          }));
        },
        getAll(store) {
          return this.open().then(db => new Promise((res, rej) => {
            const tx = db.transaction(store, 'readonly'); const st = tx.objectStore(store);
            const req = st.getAll();
            req.onsuccess = () => res(req.result);
            req.onerror = () => rej(req.error);
          }));
        },
        clear(store) {
          return this.open().then(db => new Promise((res, rej) => {
            const tx = db.transaction(store, 'readwrite'); const st = tx.objectStore(store);
            const req = st.clear();
            req.onsuccess = () => res();
            req.onerror = () => rej(req.error);
          }));
        }
      };

      // ---- App ----
      class TradingApp {
        constructor() {
          // state
          this.symbol = 'BTCUSDT';
          this.timeframe = '1m';
          this.livePrice = 0;
          this.priceChange = 0;
          this.isConnected = false;
          this.lastKlines = [];
          this.lastOrderbook = { bid: 0, ask: 0 };
          this.lastSpreadPct = 0;
          this.predictions = [];
          this.batches = [];
          this.history = [];
          this.isAnalyzing = false;
          this.currentBatch = 0;
          this.uidrawIntervalMs = 900;
          this.lastUIDraw = 0;
          this.intervals = new Set();

          // risk & paper account
          this.accountBalance = 10000;
          this.dailyPnL = 0;
          this.openPositions = [];
          this.tradeLog = [];
          this.tradingEnabled = true;
          this.riskCaps = {
            maxRiskPerTradePct: 0.5,
            maxExposurePct: 20,
            dailyLossStopPct: 2,
            slippageGuardPct: 0.12, // % spread threshold (adjusted)
            minConfidenceBuy: 55,
            minConfidenceSell: 55
          };
          this.feeModel = { maker: 0.0002, taker: 0.0004 };

          // learning system (kept but unchanged)
          this.learningSystem = {
            patternWeights: { orderBlocks:1, liquidityPools:1, fairValueGaps:1, marketStructure:1, emaContext:1, rsiDivergence:1, volumeProfile:1, priceAction:1, trendStrength:1 },
            contextWeights: { uptrend:1, downtrend:1, ranging:1 },
            correctionHistory: [], successHistory: [], adaptiveLearning:true, marketBias:0, recentSignals:[], signalDistribution:{buy:0,sell:0,hold:0}
          };

          this.marketAnalysisCache = { lastAnalysis:null, timestamp:0, validity:30000 };

          this.proxyBase = 'https://ab-ai-proxy.onrender.com/proxy';
          this.init();
        }

        // initialization & event wiring
        async init() {
          this.wireUi();
          await DB.open().catch(()=>{/* ignore DB errors but still run */});
          await this.loadPersisted();
          await this.connect();
          this.drawUI();
        }

        wireUi() {
          document.getElementById('startBtn').addEventListener('click', ()=>this.generatePredictions());
          document.getElementById('backtestBtn').addEventListener('click', ()=>this.runBacktest());
          document.getElementById('killSwitchBtn').addEventListener('click', ()=>this.toggleKillSwitch());
          document.getElementById('clearHistoryBtn').addEventListener('click', ()=>this.clearHistory());
          document.getElementById('symbolSelect').addEventListener('change', (e)=>{ this.symbol = e.target.value; this.resetAndConnect(); });
          document.getElementById('timeframeSelect').addEventListener('change', (e)=>{ this.timeframe = e.target.value; this.resetAnalysis(); });
          document.querySelectorAll('.tab').forEach(t=>t.addEventListener('click', ()=>{ document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active')); document.querySelectorAll('.tab-content').forEach(c=>c.classList.remove('active')); t.classList.add('active'); document.getElementById(t.dataset.tab+'Tab').classList.add('active'); }));
          window.addEventListener('beforeunload', ()=>this.cleanup());
        }

        async loadPersisted() {
          try {
            const hist = await DB.getAll('history'); if (hist && hist.length) { this.history = hist.sort((a,b)=>b.timestamp-a.timestamp).slice(0,500); }
            const batches = await DB.getAll('batches'); if (batches && batches.length) { this.batches = batches.sort((a,b)=>b.timestamp-a.timestamp).slice(0,200); }
            const settings = await DB.getAll('settings');
            if (settings) {
              settings.forEach(s => {
                if (s.key === 'accountBalance') this.accountBalance = s.value;
                if (s.key === 'riskCaps') this.riskCaps = Object.assign(this.riskCaps, s.value);
              });
            }
          } catch (e) { console.warn('IndexedDB load failed', e); }
        }

        persistHistoryItem(item) { DB.put('history', item).catch(()=>{}); }
        persistBatch(batch) { DB.put('batches', batch).catch(()=>{}); }
        persistSetting(key, value) { DB.put('settings', { key, value }).catch(()=>{}); }

        // connection helpers
        async connect() {
          try {
            await this.fetchOrderbook(); // sets spread
            await this.updateKlines(120);
            await this.fetchLivePrice();
            this.isConnected = true; document.getElementById('connectionStatus').textContent = 'Connected âœ…'; document.getElementById('connectionStatus').style.color = '#10b981';
            this.startLiveTicks();
          } catch (e) {
            console.warn('Connect failed, using simulated updates', e);
            this.isConnected = false; document.getElementById('connectionStatus').textContent = 'Offline (simulated)'; document.getElementById('connectionStatus').style.color = '#f59e0b';
            this.startSimulatedTicks();
          }
        }

        async resetAndConnect() {
          this.cleanup();
          this.resetAnalysis();
          await this.connect();
          this.drawUI();
        }

        // fetch: ticker, klines, orderbook (orderbook used for spread and slippage model)
        async fetchLivePrice() {
          try {
            const res = await fetch(`${this.proxyBase}/ticker?symbol=${this.symbol}`, { cache:'no-store' });
            if (!res.ok) throw new Error('HTTP '+res.status);
            const d = await res.json();
            const newPrice = Number(d.price);
            if (!isFinite(newPrice) || newPrice<=0) throw new Error('bad price');
            this.priceChange = this.livePrice ? newPrice - this.livePrice : 0;
            this.livePrice = newPrice;
            this.updateLivePriceDisplay();
            return newPrice;
          } catch (e) {
            console.warn('fetchLivePrice failed', e);
            return this.livePrice;
          }
        }

        async fetchOrderbook(limit=5) {
          // expects proxy to return { bids:[[price,qty],...], asks:[[price,qty],...] }
          try {
            const res = await fetch(`${this.proxyBase}/depth?symbol=${this.symbol}&limit=${limit}`, { cache:'no-store' });
            if (!res.ok) throw new Error('HTTP '+res.status);
            const d = await res.json();
            const bestBid = Number(d.bids?.[0]?.[0] || 0);
            const bestAsk = Number(d.asks?.[0]?.[0] || 0);
            if (bestBid && bestAsk) {
              this.lastOrderbook = { bid:bestBid, ask:bestAsk };
              this.lastSpreadPct = ((bestAsk - bestBid)/((bestAsk+bestBid)/2))*100;
            } else {
              // fallback to candle-based coarse spread if orderbook missing
              const last = this.lastKlines[this.lastKlines.length-1];
              if (last && last.close) {
                this.lastOrderbook = { bid:last.close, ask:last.close };
                this.lastSpreadPct = ((last.high-last.low)/last.close)*100 || 0;
              }
            }
            return this.lastOrderbook;
          } catch (e) {
            console.warn('fetchOrderbook failed', e);
            return this.lastOrderbook;
          }
        }

        async fetchKlineData(limit=100) {
          try {
            const res = await fetch(`${this.proxyBase}/klines?symbol=${this.symbol}&interval=${this.timeframe}&limit=${limit}`, { cache:'no-store' });
            if (!res.ok) throw new Error('HTTP '+res.status);
            const data = await res.json();
            if (!Array.isArray(data) || data.length===0) throw new Error('invalid klines');
            return data.map(k => ({
              time: k[0], open:+k[1], high:+k[2], low:+k[3], close:+k[4], volume:+k[5], closeTime:k[6], quoteVolume:+k[7]
            }));
          } catch (e) {
            console.warn('fetchKlineData failed', e);
            return this.generateSimulatedKlineData(limit);
          }
        }

        async updateKlines(limit=120) {
          this.lastKlines = await this.fetchKlineData(limit);
          // update approximate spread from last candle if orderbook not available
          if (!this.lastOrderbook.bid || !this.lastOrderbook.ask) {
            const last = this.lastKlines[this.lastKlines.length-1];
            if (last && last.close) this.lastSpreadPct = ((last.high-last.low)/last.close)*100 || 0;
          }
        }

        generateSimulatedKlineData(limit=100) {
          const out=[]; let price = this.livePrice || 45000; const now=Date.now();
          for(let i=0;i<limit;i++){ const change=(Math.random()-0.5)*200; price=Math.max(100, price+change); const high=price+Math.random()*80; const low=price-Math.random()*80; out.push({ time: now - (limit-i)*60000, open: price-change, high, low, close: price, volume: 800+Math.random()*1200, closeTime: now - (limit-i-1)*60000, quoteVolume: 40000+Math.random()*20000 }); }
          return out;
        }

        // ---- SMC & indicators (kept compact) ----
        calculateEMA(closes, period=14) {
          if(!Array.isArray(closes)||closes.length===0) return { fast:0, slow:0 };
          const v = closes.filter(Number.isFinite);
          if(!v.length) return {fast:0,slow:0};
          const mult = 2/(period+1);
          let emaFast=v[0], emaSlow=v[0];
          for(let i=1;i<v.length;i++){ emaFast=(v[i]-emaFast)*mult+emaFast; emaSlow=(v[i]-emaSlow)*(mult*0.5)+emaSlow; }
          return { fast:emaFast, slow:emaSlow };
        }
        calculateRSI(closes, period=14) {
          if(!Array.isArray(closes)||closes.length<period+1) return 50;
          let gains=0, losses=0;
          for(let i=closes.length-period;i<closes.length;i++){ const ch=closes[i]-closes[i-1]; if(ch>0) gains+=ch; else losses-=ch; }
          if(gains===0&&losses===0) return 50;
          const avgGain=gains/period, avgLoss=losses/period; if(avgLoss===0) return 100; const rs=avgGain/avgLoss; return Math.max(0,Math.min(100,100-(100/(1+rs))));
        }
        calculateMACD(closes){ if(!Array.isArray(closes)||closes.length<26) return { macdLine:0, signalLine:0, histogram:0 }; const e12=this.calculateEMA(closes,12), e26=this.calculateEMA(closes,26); const macd=e12.fast-e26.slow; const sig=macd*0.8; return { macdLine:macd, signalLine:sig, histogram:macd-sig }; }
        calculateStochastic(klineData, period=14){ if(!klineData||klineData.length<period) return {k:50,d:50}; const recent=klineData.slice(-period); const highs=recent.map(c=>c.high), lows=recent.map(c=>c.low); const hh=Math.max(...highs), ll=Math.min(...lows); if(hh===ll) return {k:50,d:50}; const cur=recent[recent.length-1].close; const k=( (cur-ll)/(hh-ll) )*100; return { k:Math.max(0,Math.min(100,k)), d: k*0.8 }; }

        // performSMCAnalysis simplified -> returns analysis with reasonCodes
        analyzeMarketContext(klineData){
          if(!klineData||klineData.length<50) return { context:'ranging', strength:0, ema50:0, ema200:0, momentum:0 };
          try{
            const closes=klineData.map(k=>k.close).filter(Number.isFinite);
            const ema50=this.calculateEMA(closes,50), ema200=this.calculateEMA(closes,200);
            const current=closes[closes.length-1];
            const recent=closes.slice(-20);
            const momentum = this.calculateMomentum(recent);
            const priceVsEma50 = ((current-ema50.fast)/ema50.fast)*100 || 0;
            const ema50VsEma200 = ((ema50.fast-ema200.slow)/ema200.slow)*100 || 0;
            let ctx='ranging', strength=0;
            if(priceVsEma50>0.5 && ema50VsEma200>0.3 && momentum>0){ ctx='uptrend'; strength=Math.min(100,Math.abs(priceVsEma50)+Math.abs(momentum*10)); }
            else if(priceVsEma50<-0.5 && ema50VsEma200<-0.3 && momentum<0){ ctx='downtrend'; strength=Math.min(100,Math.abs(priceVsEma50)+Math.abs(momentum*10)); }
            else strength=Math.max(0,50-Math.abs(momentum*25));
            // update bias (slow)
            if(ctx==='uptrend') this.learningSystem.marketBias = Math.min(100, this.learningSystem.marketBias + 8);
            else if(ctx==='downtrend') this.learningSystem.marketBias = Math.max(-100, this.learningSystem.marketBias - 8);
            else this.learningSystem.marketBias *= 0.92;
            return { context:ctx, strength, ema50:ema50.fast, ema200:ema200.slow, momentum };
          } catch(e){ return { context:'ranging', strength:0, ema50:0, ema200:0, momentum:0 }; }
        }
        calculateMomentum(prices){ if(!prices||prices.length<10) return 0; const recent=prices.slice(-5); const prev=prices.slice(-10,-5); const r=recent.reduce((a,b)=>a+b,0)/recent.length; const p=prev.reduce((a,b)=>a+b,0)/prev.length; return ((r-p)/p)*100; }

        async performSMCAnalysis(klineData){
          try{
            const now=Date.now();
            if(this.marketAnalysisCache.lastAnalysis && (now - this.marketAnalysisCache.timestamp) < this.marketAnalysisCache.validity) return this.marketAnalysisCache.lastAnalysis;
            const marketContext = this.analyzeMarketContext(klineData);
            const currentPrice = klineData[klineData.length-1].close;
            const rsi = this.calculateRSI(klineData.map(k=>k.close),14);
            const macd = this.calculateMACD(klineData.map(k=>k.close));
            const stochastic = this.calculateStochastic(klineData);
            const volumeProfile = this.analyzeVolumeProfile(klineData);
            // simple scoring & reason codes
            let score = 0; const reasonCodes = []; const reasoning=[];
            if(volumeProfile.direction==='bullish'){ score += volumeProfile.strength*0.3; reasonCodes.push('vol_bull'); reasoning.push(`Vol ${volumeProfile.buyPercentage.toFixed(1)}%`); }
            else if(volumeProfile.direction==='bearish'){ score -= volumeProfile.strength*0.3; reasonCodes.push('vol_bear'); }
            if(rsi<30){ score+=20; reasonCodes.push('rsi_os'); reasoning.push('RSI OS'); } else if(rsi>70){ score-=20; reasonCodes.push('rsi_ob'); }
            if(macd.histogram>0 && macd.macdLine>macd.signalLine){ score+=8; reasonCodes.push('macd_bull'); } else if(macd.histogram<0){ score-=8; reasonCodes.push('macd_bear'); }
            if(stochastic.k<20){ score+=10; reasonCodes.push('sto_os'); } else if(stochastic.k>80){ score-=10; reasonCodes.push('sto_ob'); }
            score -= this.learningSystem.marketBias*0.18;
            const analysis = { score, reasoning: reasoning.length?reasoning:['analysis'], reasonCodes: [...new Set(reasonCodes)], marketContext, rsi, macd, stochastic, volumeProfile, currentPrice };
            this.marketAnalysisCache.lastAnalysis = analysis; this.marketAnalysisCache.timestamp = now;
            return analysis;
          } catch(e){ return { score:0, reasoning:['default'], reasonCodes:['default'], marketContext:{context:'ranging', strength:0}, rsi:50, macd:{macdLine:0,signalLine:0,histogram:0}, stochastic:{k:50,d:50}, volumeProfile:{strength:0,direction:'neutral',buyPercentage:50}, currentPrice:this.livePrice||45000 }; }
        }

        analyzeVolumeProfile(klineData){
          if(!klineData||klineData.length<20) return {strength:0,direction:'neutral',buyPercentage:50};
          const recent=klineData.slice(-20); let buy=0,sell=0; recent.forEach(c=> { if(c.close>c.open) buy+=c.volume; else sell+=c.volume; });
          const total=buy+sell; if(total===0) return {strength:0,direction:'neutral',buyPercentage:50};
          const buyPct=(buy/total)*100; const dir = buyPct>60?'bullish': buyPct<40?'bearish':'neutral'; return { strength: Math.abs(50-buyPct)*2, direction:dir, buyPercentage:buyPct };
        }

        // ---- Prediction generation ----
        async generatePredictions() {
          if (!this.tradingEnabled) { this.showMessage('Kill switch active. Trading disabled.'); return; }
          if (this.isAnalyzing) return;
          this.isAnalyzing = true; this.currentBatch++;
          document.getElementById('startBtn').textContent = 'Running SMC Analysis...'; document.getElementById('startBtn').disabled=true;
          this.predictions = []; this.updatePredictionDisplay();
          try {
            await Promise.all([this.updateKlines(120), this.fetchOrderbook()]);
            const klineData = this.lastKlines;
            const start = this.getBinanceTime();
            const batchPreds = [];
            this.marketAnalysisCache.lastAnalysis = null;
            for (let i=1;i<=5;i++) {
              this.updateProgress(i*20);
              await this.delay(400 + Math.random()*300);
              const pred = await this.generateSMCPrediction(i, start, klineData);
              if (pred) {
                // risk gate
                if (this.validateSignalRisk(pred)) {
                  this.predictions.push(pred); batchPreds.push(pred);
                  this.learningSystem.recentSignals.push(pred.type); if(this.learningSystem.recentSignals.length>50) this.learningSystem.recentSignals.shift();
                  // auto paper execute if trade (non-HOLD)
                  if (pred.type!=='HOLD') this.executeTrade(pred,'paper');
                  this.persistHistoryItem(pred);
                } else {
                  pred.reasoning.unshift('Risk gate blocked'); pred.reasonCodes.push('risk_block'); pred.type='HOLD';
                  this.predictions.push(pred); batchPreds.push(pred);
                }
                this.updateUINow();
              }
            }
            if(batchPreds.length) {
              const batch = { id: start, timestamp:start, predictions: batchPreds };
              this.batches.unshift(batch); this.persistBatch(batch);
              this.history.unshift(...batchPreds);
              this.updateHistory();
              this.updateSignalStats();
              this.updatePerformance();
              this.showMessage(`SMC Analysis completed: ${batchPreds.length} predictions`);
            }
          } catch (e) {
            console.error('generatePredictions error', e);
            this.showMessage('Analysis error - using fallback predictions');
          } finally {
            this.isAnalyzing=false; document.getElementById('startBtn').textContent='Generate Smart Predictions'; document.getElementById('startBtn').disabled=false;
            this.updateProgress(0);
          }
        }

        async generateSMCPrediction(seq, batchStart, klineData) {
          try {
            const timeframeMs = this.getTimeframeMs(this.timeframe);
            const ts = this.getCandleTime(batchStart + seq * timeframeMs);
            const modified = this.varyKlineData(klineData, seq);
            const analysis = await this.performSMCAnalysis(modified);
            return this.createPredictionFromAnalysis(analysis, ts, seq);
          } catch (e) { console.warn('generateSMCPrediction failed', e); return this.createEnhancedPrediction(seq, batchStart); }
        }

        varyKlineData(klineData, seq) {
          const v = 1 + (seq-3)*0.002;
          return klineData.map(k => ({ ...k, close: k.close * v }));
        }

        createPredictionFromAnalysis(analysis, ts, seq) {
          const { score, reasonCodes, marketContext, currentPrice } = analysis;
          let baseConfidence = 50 + (score/2) + (seq-3)*4 + (Math.random()-0.5)*10;
          const confidence = Math.min(90, Math.max(25, baseConfidence));
          let type='HOLD';
          // thresholds aligned to riskCaps and market context
          if(marketContext.context==='uptrend'){ if(confidence>=this.riskCaps.minConfidenceBuy) type='BUY'; else if(confidence<=35) type='SELL'; }
          else if(marketContext.context==='downtrend'){ if(confidence>=65) type='BUY'; else if(confidence<=this.riskCaps.minConfidenceSell-10) type='SELL'; }
          else { if(confidence>=60) type='BUY'; else if(confidence<=40) type='SELL'; }
          const atr = this.estimateATR(currentPrice);
          const entry = currentPrice || this.livePrice || 45000;
          let stop=entry, target=entry, rr=0;
          if(type==='BUY'){ stop=Math.max(entry - atr*1.5, entry*0.985); target = entry + (entry-stop)*(2+Math.random()*0.6); rr = ((target-entry)/(entry-stop)).toFixed(2); }
          else if(type==='SELL'){ stop=Math.min(entry + atr*1.5, entry*1.015); target = entry - (stop-entry)*(2+Math.random()*0.6); rr = ((entry-target)/(stop-entry)).toFixed(2); }
          const reason = (analysis.reasoning && analysis.reasoning.slice(0,3)) || [ 'market' ];
          return {
            id: ts + '-' + seq, binanceTimestamp: ts, candleTime: new Date(ts).toISOString(),
            sequence: seq, timestamp: Date.now(), symbol:this.symbol, timeframe:this.timeframe,
            type, entry: +entry.toFixed(2), stop: +stop.toFixed(2), target: +target.toFixed(2),
            riskReward: +rr, confidence: +confidence.toFixed(1), reasoning: reason, reasonCodes: reasonCodes || [],
            marketContext, indicators:{ rsi: analysis.rsi, macd: analysis.macd, stochastic: analysis.stochastic }, outcome:'Active', batch:this.currentBatch, dataSource:this.isConnected?'Binance Live':'Simulated'
          };
        }

        createEnhancedPrediction(seq, batchStart) {
          const timeframeMs=this.getTimeframeMs(this.timeframe); const ts=this.getCandleTime(batchStart + seq*timeframeMs);
          const rand=Math.random(); let type='HOLD';
          if(seq<=2) type = rand<0.4?'BUY': rand<0.7?'SELL':'HOLD';
          else if(seq<=4) type = rand<0.35?'SELL': rand<0.7?'BUY':'HOLD';
          else type = rand<0.33?'BUY': rand<0.66?'SELL':'HOLD';
          const entry=this.livePrice||45000; let stop=entry, target=entry, rr=0;
          if(type==='BUY'){ stop = entry*(0.986 + Math.random()*0.007); target = entry*(1.02 + Math.random()*0.02); rr = ( (target-entry)/(entry-stop) ).toFixed(2); }
          if(type==='SELL'){ stop = entry*(1.014 - Math.random()*0.007); target = entry*(0.98 - Math.random()*0.02); rr = ( (entry-target)/(stop-entry) ).toFixed(2); }
          const reasonCodes=['sim']; return {
            id: ts+'-'+seq, binanceTimestamp:ts, candleTime:new Date(ts).toISOString(), sequence:seq, timestamp:Date.now(),
            symbol:this.symbol, timeframe:this.timeframe, type, entry:+entry.toFixed(2), stop:+stop.toFixed(2), target:+target.toFixed(2),
            riskReward: type==='HOLD'?0:+rr, confidence: Math.min(90, Math.max(30, 50 + (type==='BUY'?10:-10) + (Math.random()-0.5)*20)), reasoning:['simulated','market_analysis'], reasonCodes, marketContext:{context:['uptrend','downtrend','ranging'][Math.floor(Math.random()*3)], strength:30+Math.random()*40}, indicators:{rsi:35+Math.random()*30}, outcome:'Active', batch:this.currentBatch, dataSource:'Simulated'
          };
        }

        estimateATR(price) { return (price||this.livePrice||45000)*0.012; }

        // ---- Risk gating & execution (paper) ----
        validateSignalRisk(pred) {
          // daily loss stop enforced
          const dailyStop = -(this.accountBalance * (this.riskCaps.dailyLossStopPct / 100));
          if(this.dailyPnL <= dailyStop){ this.tradingEnabled=false; this.showMessage('Daily loss stop reached. Trading disabled.'); return false; }
          // confidence check
          if(pred.type==='BUY' && pred.confidence < this.riskCaps.minConfidenceBuy) return false;
          if(pred.type==='SELL' && pred.confidence < this.riskCaps.minConfidenceSell) return false;
          // spread/slippage guard: use orderbook spread percent
          if(this.lastSpreadPct > this.riskCaps.slippageGuardPct) return false;
          // exposure cap
          const exposureNow = this.openPositions.reduce((s,p)=>s + (p.qty * p.entry),0);
          const toOpenUsd = this.computePositionSizeUsd(pred);
          const exposurePct = ((exposureNow + toOpenUsd) / this.accountBalance) * 100;
          if(exposurePct > this.riskCaps.maxExposurePct) return false;
          // stop sanity
          if(pred.type==='BUY' && pred.stop >= pred.entry) return false;
          if(pred.type==='SELL' && pred.stop <= pred.entry) return false;
          return true;
        }

        computePositionSizeUsd(pred) {
          const riskUsd = this.accountBalance * (this.riskCaps.maxRiskPerTradePct / 100);
          const perUnitRisk = Math.abs(pred.entry - pred.stop);
          if(perUnitRisk<=0) return 0;
          const qty = riskUsd / perUnitRisk;
          return qty * pred.entry;
        }

        executeTrade(pred, mode='paper') {
          if(!this.tradingEnabled || pred.type==='HOLD') return;
          const feeRate = this.feeModel.taker;
          const qty = Math.max(0, (this.accountBalance * (this.riskCaps.maxRiskPerTradePct/100)) / Math.abs(pred.entry - pred.stop || 1));
          if(qty<=0) return;
          // slippage based on half spread and small random factor, but bounded
          const spread = Math.max( (this.lastOrderbook.ask - this.lastOrderbook.bid) || 0, (this.livePrice*0.0001) );
          const slip = (spread/2) * (0.5 + Math.random()*0.5);
          const entryFill = pred.type==='BUY' ? pred.entry + slip : pred.entry - slip;
          const fees = entryFill * qty * feeRate;
          const pos = { id:'POS-'+pred.id, type:pred.type, qty, entry: +entryFill.toFixed(6), stop:pred.stop, target:pred.target, feeRate, openedAt:Date.now(), reason: pred.reasoning.join(' | ') };
          this.openPositions.push(pos);
          this.tradeLog.push({ id:pos.id, type:pos.type, qty:pos.qty, entry:pos.entry, exit:null, pnl:null, fees, openedAt:pos.openedAt, closedAt:null, reason:pos.reason });
          // monitor closes (paper) with per-position interval
          const tick = setInterval(()=> this.checkPositionExit(pos), 1500);
          pos._tick = tick; this.intervals.add(tick);
        }

        checkPositionExit(pos) {
          const price = this.livePrice || pos.entry;
          let exit=false, exitPrice = price;
          if(pos.type==='BUY'){
            if(price <= pos.stop){ exit=true; exitPrice=pos.stop; }
            else if(price >= pos.target){ exit=true; exitPrice=pos.target; }
          } else {
            if(price >= pos.stop){ exit=true; exitPrice=pos.stop; }
            else if(price <= pos.target){ exit=true; exitPrice=pos.target; }
          }
          if(exit) this.closePosition(pos, exitPrice);
        }

        closePosition(pos, exitPrice) {
          if(pos._tick){ clearInterval(pos._tick); this.intervals.delete(pos._tick); pos._tick=null; }
          const feesExit = exitPrice * pos.qty * pos.feeRate;
          const grossPnL = pos.type==='BUY' ? (exitPrice - pos.entry) * pos.qty : (pos.entry - exitPrice) * pos.qty;
          const totalFees = (pos.entry * pos.qty * pos.feeRate) + feesExit;
          const netPnL = grossPnL - totalFees;
          this.dailyPnL += netPnL; this.accountBalance += netPnL;
          // update tradeLog
          const log = this.tradeLog.find(t=>t.id===pos.id);
          if(log){ log.exit = exitPrice; log.pnl = netPnL; log.closedAt = Date.now(); log.fees = (log.fees||0) + feesExit; }
          // remove from open
          this.openPositions = this.openPositions.filter(p=>p.id!==pos.id);
          // kill switch
          const dailyStop = -(this.accountBalance * (this.riskCaps.dailyLossStopPct/100));
          if(this.dailyPnL <= dailyStop){ this.tradingEnabled=false; this.showMessage('Daily loss stop reached. Kill switch engaged.'); }
          this.updatePerformance();
        }

        // ---- Backtester (event based, simplified) ----
        async runBacktest() {
          this.showMessage('Running backtest...');
          try {
            await this.updateKlines(400);
            const data = this.lastKlines;
            let equity = 10000, peak = equity, trough = equity, wins=0, losses=0, trades=0;
            const fee = this.feeModel.taker;
            for(let i=80;i<data.length-1;i++){
              const window = data.slice(i-80,i);
              const analysis = await this.performSMCAnalysis(window);
              const pred = this.createPredictionFromAnalysis(analysis, data[i].time, 0);
              if(!pred || pred.type==='HOLD') continue;
              // simulate entry at next candle open
              const next = data[i+1];
              const entry = pred.type==='BUY' ? Math.min(next.open, pred.entry) : Math.max(next.open, pred.entry);
              const perUnitRisk = Math.abs(pred.entry - pred.stop);
              if(perUnitRisk<=0) continue;
              const qty = (equity*(this.riskCaps.maxRiskPerTradePct/100))/perUnitRisk;
              // walk-forward 10 candles
              let exit = entry, hit=false;
              for(let j=i+1;j<Math.min(i+11,data.length);j++){
                const c = data[j];
                if(pred.type==='BUY'){
                  if(c.low <= pred.stop){ exit = pred.stop; hit=true; break; }
                  if(c.high >= pred.target){ exit = pred.target; hit=true; break; }
                } else {
                  if(c.high >= pred.stop){ exit = pred.stop; hit=true; break; }
                  if(c.low <= pred.target){ exit = pred.target; hit=true; break; }
                }
              }
              const fees = (entry*qty*fee) + (exit*qty*fee);
              const pnl = pred.type==='BUY' ? (exit-entry)*qty - fees : (entry-exit)*qty - fees;
              equity += pnl; trades++; if(pnl>0) wins++; else losses++;
              peak = Math.max(peak,equity); trough = Math.min(trough,equity);
            }
            const drawdown = ((peak - trough)/peak)*100;
            this.showBacktestResult(trades, equity, wins, losses, drawdown);
          } catch (e) { console.error('backtest failed', e); this.showMessage('Backtest error'); }
        }

        showBacktestResult(trades, equity, wins, losses, drawdown) {
          const container = document.getElementById('performanceContainer');
          container.innerHTML = `
            <div class="analysis-card"><div style="font-weight:600">Backtest Summary</div>
            <div style="margin-top:8px">Trades: ${trades} â€¢ Final equity: $${equity.toFixed(2)}</div>
            <div style="margin-top:6px">Wins: ${wins} â€¢ Losses: ${losses} â€¢ Max drawdown: ${drawdown.toFixed(2)}%</div></div>
          `;
        }

        // ---- UI updates & helpers ----
        getBinanceTime(){ return Date.now(); }
        getCandleTime(ts){ const ms=this.getTimeframeMs(this.timeframe); return Math.floor(ts/ms)*ms; }
        getTimeframeMs(tf){ const m=60*1000; switch(tf){ case '1m': return m; case '5m': return 5*m; case '15m': return 15*m; case '1h': return 60*m; default: return m; } }

        updateProgress(p){ document.getElementById('analysisProgress').style.width = (p||0)+'%'; document.getElementById('progressText').textContent = `SMC Analysis progress: ${p||0}%`; }

        updateLivePriceDisplay(){
          const el=document.getElementById('livePrice');
          const cls = (this.priceChange>=0)?'price-up':'price-down';
          const sym = (this.priceChange>=0)?'â†—':'â†˜';
          el.innerHTML = `${this.symbol}: <span style="color:${this.priceChange>=0? '#10b981':'#ef4444'}; font-weight:700">$${(this.livePrice||0).toFixed(2)}</span> <span style="font-size:0.85rem; margin-left:8px; color:#94a3b8">${sym} ${Math.abs(this.priceChange).toFixed(2)}</span> <span style="margin-left:10px; color:#94a3b8; font-size:0.85rem">Spread: ${this.lastSpreadPct.toFixed(3)}%</span>`;
        }

        updatePredictionDisplay(){
          const container = document.getElementById('predictionContainer');
          if(!this.predictions || this.predictions.length===0){
            container.innerHTML = `<div class="loading"><div class="pulse">Click "Generate Smart Predictions" to start</div></div>`; return;
          }
          // limit rendered predictions for performance
          const items = this.predictions.slice(0,12);
          const html = `<div class="predictions-grid">${items.map(pred => {
            const disp = pred.correctedType || pred.type;
            const cls = disp.toLowerCase();
            const reason = (pred.reasoning||[]).slice(0,3).join(', ');
            return `<div class="prediction-card ${cls}">
              <div class="prediction-header"><div class="prediction-type">${disp}</div><div class="prediction-confidence">${pred.confidence}%</div></div>
              <div class="prediction-price">$${pred.entry}</div>
              <div class="prediction-details"><div>Stop: $${pred.stop}</div><div>Target: $${pred.target}</div><div>R/R: ${pred.riskReward}</div></div>
              <div class="adaptive-indicators"><span class="indicator-tag">${pred.marketContext.context}</span><span class="indicator-tag">RSI:${Math.round(pred.indicators?.rsi||50)}</span></div>
              <div style="margin-top:8px; color:#94a3b8; font-size:0.82rem">${reason}</div>
              <div style="display:flex; gap:6px; margin-top:8px;"><button class="btn btn-success" onclick="app.recordOutcome('${pred.id}','Success')">Correct</button><button class="btn btn-danger" onclick="app.showCorrectionDialog('${pred.id}')">Wrong</button></div>
            </div>`;
          }).join('')}</div>`;
          container.innerHTML = html;
          document.getElementById('lastUpdate').textContent = `Batch ${this.currentBatch} â€¢ ${this.isConnected?'Live':'Simulated'} â€¢ ${new Date().toLocaleTimeString()}`;
        }

        updateHistory() {
          const container = document.getElementById('historyContainer');
          if(!this.batches || this.batches.length===0){ container.innerHTML = `<div class="loading"><div class="pulse">No history yet</div></div>`; return; }
          const html = this.batches.slice(0,8).map((batch,bi) => {
            return `<div class="analysis-card"><div style="display:flex;justify-content:space-between"><div style="font-weight:600">Batch ${bi+1}</div><div style="color:#94a3b8">${new Date(batch.timestamp).toLocaleString()}</div></div>
              <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr)); gap:8px; margin-top:8px">
              ${batch.predictions.slice(0,6).map(p=>`<div style="background:rgba(255,255,255,0.02); padding:8px; border-radius:6px"><div style="font-weight:700">${p.type}</div><div style="color:#94a3b8">Entry: $${p.entry}</div><div style="color:#94a3b8">C:${p.confidence}%</div></div>`).join('')}
              </div></div>`;
          }).join('');
          container.innerHTML = html;
        }

        updatePerformance() {
          const container = document.getElementById('performanceContainer');
          const rated = this.history.filter(p=>p.outcome && p.outcome!=='Active');
          const total = rated.length;
          const successCount = rated.filter(r=>r.outcome==='Success').length;
          const corrected = rated.filter(r=>r.outcome==='Corrected').length;
          const openExposure = this.openPositions.reduce((s,p)=>s + (p.qty*p.entry),0);
          const wins = this.tradeLog.filter(t=>t.pnl>0).length;
          const losses = this.tradeLog.filter(t=>t.pnl<0).length;
          const dd = this.computePaperDrawdown();
          if(total===0){
            container.innerHTML = `<div class="loading"><div class="pulse">Rate predictions to see performance</div></div>`; return;
          }
          const successRate = total-corrected>0?((successCount/(total-corrected))*100).toFixed(1):'0.0';
          container.innerHTML = `<div class="analysis-card"><div style="font-weight:600">SMC Success Rate: ${successRate}%</div><div style="margin-top:8px">Rated: ${total} (${corrected} corrected)</div></div>
            <div class="analysis-card"><div style="font-weight:600">Paper Trading</div><div style="margin-top:8px">Net PnL: $${this.tradeLog.reduce((s,t)=>s+(t.pnl||0),0).toFixed(2)} â€¢ Daily PnL: $${this.dailyPnL.toFixed(2)}</div><div style="margin-top:6px">Open positions: ${this.openPositions.length} â€¢ Exposure: $${openExposure.toFixed(2)}</div><div style="margin-top:6px">Drawdown: ${dd.toFixed(2)}%</div></div>`;
        }

        computePaperDrawdown(){ let equity=10000, peak=10000, dd=0; this.tradeLog.forEach(t=>{ if(typeof t.pnl==='number'){ equity+=t.pnl; peak = Math.max(peak,equity); const drop = peak>0?((peak-equity)/peak)*100:0; dd=Math.max(dd,drop); }}); return dd; }

        updateSignalStats(){ /* minimal: show counts of last predictions */ const buys=this.predictions.filter(p=>p.type==='BUY').length; const sells=this.predictions.filter(p=>p.type==='SELL').length; const holds=this.predictions.filter(p=>p.type==='HOLD').length; /* no dedicated UI elements for counts here to keep DOM light */ }

        updateUINow(){
          const now=Date.now(); if(now - this.lastUIDraw < this.uidrawIntervalMs) return; this.lastUIDraw = now;
          this.updateLivePriceDisplay(); this.updatePredictionDisplay(); this.updateSMCAnalysis(); this.updateRiskManagement(); this.updatePerformance();
        }

        updateSMCAnalysis(){
          if(!this.predictions.length) return;
          const last = this.predictions[0] || this.predictions[this.predictions.length-1];
          const sc = document.getElementById('smcContainer');
          sc.innerHTML = `<div class="analysis-card"><div style="display:flex;justify-content:space-between"><div style="font-weight:600">Context</div><div style="color:#94a3b8">${last.marketContext.context}</div></div><div style="margin-top:6px">Strength: ${last.marketContext.strength.toFixed(1)}%</div></div>`;
        }

        updateRiskManagement(){
          const el = document.getElementById('riskContent');
          if(!this.predictions.length){ el.innerHTML = `<div class="loading"><div class="pulse">Risk summary will appear after predictions</div></div>`; return; }
          const last = this.predictions[0] || this.predictions[this.predictions.length-1];
          if(last.type==='HOLD'){ el.innerHTML = '<div>No active trade â€” market unclear</div>'; return; }
          const plannedUsd = this.computePositionSizeUsd(last); const pct = ((plannedUsd/this.accountBalance)*100).toFixed(2);
          el.innerHTML = `<div><strong>Planned Position:</strong> ${pct}% of portfolio</div><div style="color:#94a3b8; margin-top:6px">Stop: $${last.stop} â€¢ Target: $${last.target} â€¢ R/R: ${last.riskReward}</div>${!this.tradingEnabled?'<div class="risk-killswitch">Kill switch active â€” no new trades</div>':''}`;
        }

        showMessage(msg){ document.getElementById('smcContainer').innerHTML = `<div class="analysis-card"><div style="font-weight:600">System</div><div style="margin-top:8px">${msg}</div></div>`; }

        // ---- user interactions ----
        recordOutcome(predId, outcome){
          [this.predictions, this.history].forEach(col => { const p = col.find(x=>x.id===predId); if(p) p.outcome = outcome; });
          this.batches.forEach(b => { b.predictions.forEach(p=>{ if(p.id===predId) p.outcome=outcome; }); });
          this.adaptiveLearnFromOutcome(predId, outcome);
          this.updateHistory(); this.updatePerformance(); this.updatePredictionDisplay();
        }

        showCorrectionDialog(predId) {
          const pred = this.predictions.find(p=>p.id===predId) || this.history.find(h=>h.id===predId);
          if(!pred) return;
          const actual = prompt(`Prediction ${pred.type}. Enter actual direction: BUY, SELL, or HOLD`);
          if(!actual) return;
          const up = actual.toUpperCase();
          if(!['BUY','SELL','HOLD'].includes(up)){ alert('Enter BUY, SELL or HOLD'); return; }
          this.adaptiveLearnFromOutcome(predId, 'Corrected', up);
          this.recordOutcome(predId, 'Corrected');
        }

        adaptiveLearnFromOutcome(predictionId, outcome, actualMarket){
          const prediction = this.history.find(p=>p.id===predictionId) || this.predictions.find(p=>p.id===predictionId);
          if(!prediction) return;
          if(actualMarket && actualMarket!==prediction.type){
            this.learningSystem.correctionHistory.push({timestamp:Date.now(), predicted:prediction.type, actual:actualMarket, patterns:prediction.smcPatterns, context:prediction.marketContext, reasonCodes:prediction.reasonCodes});
            // slight penalty adjustments
            (prediction.smcPatterns||[]).forEach(pat=>{ if(this.learningSystem.patternWeights[pat]!==undefined) this.learningSystem.patternWeights[pat] = Math.max(0.4, this.learningSystem.patternWeights[pat]*0.85); });
            this.learningSystem.marketBias += (actualMarket==='BUY'?8:-8);
            prediction.correctedType = actualMarket; prediction.outcome='Corrected';
            this.showMessage(`Correction recorded: ${actualMarket}`);
            return;
          }
          // normal success/fail adjust
          const isSuccess = outcome==='Success';
          (prediction.smcPatterns||[]).forEach(pat=>{ if(this.learningSystem.patternWeights[pat]!==undefined) this.learningSystem.patternWeights[pat] = isSuccess? Math.min(2, this.learningSystem.patternWeights[pat]*1.08): Math.max(0.5, this.learningSystem.patternWeights[pat]*0.9); });
          const ctx = prediction.marketContext?.context;
          if(ctx && this.learningSystem.contextWeights[ctx]!==undefined) this.learningSystem.contextWeights[ctx] = isSuccess? Math.min(1.5, this.learningSystem.contextWeights[ctx]*1.05): Math.max(0.6, this.learningSystem.contextWeights[ctx]*0.9);
        }

        // ---- Kill switch & cleanup ----
        toggleKillSwitch(){ this.tradingEnabled = false; this.showMessage('Kill switch manually engaged. No new trades.'); document.getElementById('riskContent').innerHTML += `<div class="risk-killswitch"><strong>Kill switch active.</strong></div>`; }
        cleanup(){ // clear all intervals created
          this.intervals.forEach(i=>clearInterval(i)); this.intervals.clear();
        }

        // ---- helpers ----
        delay(ms){ return new Promise(r=>setTimeout(r,ms)); }

        // ---- startup ticking ----
        startLiveTicks(){
          this.cleanup();
          const t1 = setInterval(async ()=>{ try{ await this.fetchLivePrice(); await this.fetchOrderbook(); await this.updateKlines(120); this.updateUINow(); }catch(e){ console.warn(e); } }, 3000);
          this.intervals.add(t1);
        }
        startSimulatedTicks(){
          this.cleanup();
          const t = setInterval(()=>{ const change=(Math.random()-0.5)*80; this.livePrice = Math.max(100, (this.livePrice||45000) + change); this.priceChange = change; this.lastSpreadPct = Math.abs((Math.random()-0.5)*0.3); this.updateUINow(); }, 2500);
          this.intervals.add(t);
        }

        // ---- record & clear history ----
        async clearHistory(){
          if(!confirm('Clear all history?')) return; this.history=[]; this.batches=[]; this.tradeLog=[]; this.openPositions=[]; this.dailyPnL=0; await DB.clear('history').catch(()=>{}); await DB.clear('batches').catch(()=>{}); this.updateHistory(); this.updatePerformance(); this.showMessage('History cleared (learning preserved)');
        }

        // ---- utility: getBinanceTime wrapper used earlier ----
        getTime() { return Date.now(); }

      } // end class

      // instantiate
      window.app = new TradingApp();

      // expose minimal functions for UI buttons inside generated HTML
      window.recordOutcome = (id, outcome) => app.recordOutcome(id, outcome);
      window.showCorrectionDialog = (id) => app.showCorrectionDialog(id);
    })();
  </script>
</body>
</html>
