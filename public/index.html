<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Advanced Pro Trading AI - Smart Money Concepts</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #f8fafc;
            line-height: 1.6;
            padding: 0;
            margin: 0;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 15px;
        }

        header {
            background: rgba(30, 41, 59, 0.9);
            padding: 15px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .logo h1 {
            font-size: 1.5rem;
            background: linear-gradient(90deg, #3b82f6, #10b981);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-warning {
            background: #f59e0b;
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        select {
            padding: 10px;
            border-radius: 6px;
            background: #1e293b;
            color: #f8fafc;
            border: 1px solid #475569;
        }

        .card {
            background: rgba(30, 41, 59, 0.7);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.05);
            margin-bottom: 20px;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card-title {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .predictions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .prediction-card {
            background: rgba(15, 23, 42, 0.8);
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #64748b;
            transition: all 0.3s;
        }

        .prediction-card.buy {
            border-left-color: #10b981;
            background: rgba(16, 185, 129, 0.15);
        }

        .prediction-card.sell {
            border-left-color: #ef4444;
            background: rgba(239, 68, 68, 0.15);
        }

        .prediction-card.hold {
            border-left-color: #f59e0b;
            background: rgba(245, 158, 11, 0.15);
        }

        .prediction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .prediction-type {
            font-weight: 700;
            font-size: 1.1rem;
        }

        .prediction-type.buy {
            color: #10b981;
        }

        .prediction-type.sell {
            color: #ef4444;
        }

        .prediction-type.hold {
            color: #f59e0b;
        }

        .prediction-confidence {
            font-size: 0.8rem;
            background: rgba(255, 255, 255, 0.1);
            padding: 3px 8px;
            border-radius: 20px;
        }

        .prediction-price {
            font-size: 1.2rem;
            font-weight: 700;
            margin: 5px 0;
        }

        .prediction-details {
            font-size: 0.85rem;
            color: #94a3b8;
            margin-bottom: 10px;
        }

        .prediction-timestamp {
            font-size: 0.75rem;
            color: #64748b;
            margin-top: 5px;
        }

        .prediction-reasoning {
            font-size: 0.8rem;
            margin-top: 10px;
            color: #94a3b8;
        }

        .prediction-actions {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }

        .prediction-actions .btn {
            padding: 4px 8px;
            font-size: 0.7rem;
            flex: 1;
        }

        .progress-container {
            margin-top: 10px;
        }

        .progress-bar {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #3b82f6;
            border-radius: 3px;
            transition: width 0.3s;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #94a3b8;
        }

        .pulse {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .adaptive-indicators {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .indicator-tag {
            background: rgba(59, 130, 246, 0.2);
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            color: #3b82f6;
        }

        .analysis-card {
            background: rgba(15, 23, 42, 0.5);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .analysis-header {
            display: flex;
            justify-content: space-between;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .signal-stats {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            font-size: 0.8rem;
        }

        .signal-stat {
            padding: 5px 10px;
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.05);
        }

        .tab-container {
            margin-top: 20px;
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 20px;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab.active {
            border-bottom-color: #3b82f6;
            color: #3b82f6;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .live-price {
            font-size: 1.4rem;
            font-weight: bold;
            text-align: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .price-up {
            color: #10b981;
        }

        .price-down {
            color: #ef4444;
        }

        .smc-tag {
            background: rgba(168, 85, 247, 0.2);
            color: #a855f7;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.65rem;
            margin-left: 4px;
        }

        .status-badge {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .status-active {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
        }

        .status-success {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .status-fail {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    <h1>ðŸš€ Advanced Pro Trading AI - Smart Money Concepts</h1>
                </div>
                <div class="controls">
                    <select id="symbolSelect">
                        <option value="BTCUSDT">BTC/USDT</option>
                        <option value="ETHUSDT">ETH/USDT</option>
                        <option value="ADAUSDT">ADA/USDT</option>
                        <option value="BNBUSDT">BNB/USDT</option>
                    </select>
                    <select id="timeframeSelect">
                        <option value="1m">1 Minute</option>
                        <option value="5m">5 Minutes</option>
                        <option value="15m">15 Minutes</option>
                        <option value="1h">1 Hour</option>
                        <option value="4h">4 Hours</option>
                    </select>
                    <button id="startBtn" class="btn btn-primary">Generate Smart Predictions</button>
                    <button id="resetBtn" class="btn btn-warning">Reset Analysis</button>
                </div>
            </div>
        </div>
    </header>

    <div class="container">
        <div class="tab-container">
            <div class="tabs">
                <div class="tab active" data-tab="dashboard">Dashboard</div>
                <div class="tab" data-tab="history">History</div>
                <div class="tab" data-tab="performance">Performance</div>
                <div class="tab" data-tab="smc">SMC Analysis</div>
            </div>

            <div id="dashboardTab" class="tab-content active">
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Live Market Data</h2>
                        <div id="connectionStatus" class="prediction-details">Connecting to Binance via Render Proxy...</div>
                    </div>
                    <div id="livePrice" class="live-price">Loading real price...</div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Smart Money Concept Predictions</h2>
                        <div id="lastUpdate" class="prediction-details">Select timeframe and click Generate</div>
                    </div>

                    <div id="predictionContainer">
                        <div class="loading">
                            <div class="pulse">Click "Generate Smart Predictions" to start SMC analysis</div>
                        </div>
                    </div>

                    <div class="progress-container">
                        <div class="progress-bar">
                            <div id="analysisProgress" class="progress-fill" style="width: 0%"></div>
                        </div>
                        <div id="progressText" style="text-align: center; margin-top: 5px; font-size: 0.8rem; color: #94a3b8;">
                            SMC Analysis progress: 0%
                        </div>
                    </div>

                    <div id="signalStats" class="signal-stats" style="display: none;">
                        <div class="signal-stat buy">BUY: <span id="buyCount">0</span></div>
                        <div class="signal-stat sell">SELL: <span id="sellCount">0</span></div>
                        <div class="signal-stat hold">HOLD: <span id="holdCount">0</span></div>
                    </div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Advanced SMC Analysis</h2>
                    </div>
                    <div id="analysisContainer">
                        <div class="loading">
                            <div class="pulse">Smart Money Concept analysis will appear here</div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Risk Management</h2>
                    </div>
                    <div id="riskContent">
                        <div class="loading">
                            <div class="pulse">SMC-based risk assessment will appear here</div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="smcTab" class="tab-content">
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Smart Money Concepts Analysis</h2>
                    </div>
                    <div id="smcContainer">
                        <div class="loading">
                            <div class="pulse">SMC analysis will appear here after generating predictions</div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="historyTab" class="tab-content">
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Prediction History</h2>
                        <button id="clearHistoryBtn" class="btn btn-danger">Clear History</button>
                    </div>
                    <div id="historyContainer">
                        <div class="loading">
                            <div class="pulse">No prediction history yet. Generate some predictions first.</div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="performanceTab" class="tab-content">
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Performance Analytics</h2>
                    </div>
                    <div id="performanceContainer">
                        <div class="loading">
                            <div class="pulse">Performance data will appear here after you provide feedback</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ADVANCED TRADING AI WITH SMART MONEY CONCEPTS
        class AdvancedTradingAI {
            constructor() {
                this.symbol = 'BTCUSDT';
                this.timeframe = '1m';
                this.predictions = [];
                this.history = [];
                this.batches = [];
                this.isAnalyzing = false;
                this.currentBatch = 0;
                this.livePrice = 0;
                this.priceChange = 0;
                this.isConnected = false;
                this.binanceServerTime = null;

                // Advanced SMC Learning System
                this.learningSystem = {
                    patternWeights: {
                        orderBlocks: 1.0,
                        liquidityPools: 1.0,
                        fairValueGaps: 1.0,
                        marketStructure: 1.0,
                        emaContext: 1.0,
                        rsiDivergence: 1.0
                    },
                    contextWeights: {
                        uptrend: 1.0,
                        downtrend: 1.0,
                        ranging: 1.0
                    },
                    successHistory: []
                };

                this.init();
            }

            async init() {
                this.setupEventListeners();
                await this.connectToBinance();
                console.log("Advanced Trading AI with SMC initialized - Render Proxy Ready");
            }

            async connectToBinance() {
                try {
                    await this.fetchBinanceServerTime();
                    await this.fetchLivePrice();
                    this.isConnected = true;
                    document.getElementById('connectionStatus').textContent = 'Connected to Binance via Render âœ…';
                    document.getElementById('connectionStatus').style.color = '#10b981';
                    this.startLiveUpdates();
                } catch (error) {
                    console.error("Failed to connect to Binance:", error);
                    document.getElementById('connectionStatus').textContent = 'Render Proxy Connection âŒ - Using simulated data';
                    document.getElementById('connectionStatus').style.color = '#ef4444';
                    this.startSimulatedUpdates();
                }
            }

            async fetchBinanceServerTime() {
                try {
                    const response = await fetch('/proxy/time');
                    if (!response.ok) throw new Error('Network response was not ok');
                    const data = await response.json();
                    this.binanceServerTime = data.serverTime;
                    return data.serverTime;
                } catch (error) {
                    console.warn('Using local time as fallback');
                    this.binanceServerTime = Date.now();
                    return Date.now();
                }
            }

            async fetchLivePrice() {
                try {
                    const response = await fetch(`/proxy/ticker?symbol=${this.symbol}`);
                    if (!response.ok) throw new Error('Network response was not ok');
                    const data = await response.json();
                    const newPrice = parseFloat(data.price);
                    this.priceChange = newPrice - (this.livePrice || newPrice);
                    this.livePrice = newPrice;
                    this.updateLivePriceDisplay();
                    return newPrice;
                } catch (error) {
                    throw new Error(`Render Proxy error: ${error.message}`);
                }
            }

            async fetchKlineData(limit = 100) {
                try {
                    const response = await fetch(
                        `/proxy/klines?symbol=${this.symbol}&interval=${this.timeframe}&limit=${limit}`
                    );
                    if (!response.ok) throw new Error('Network response was not ok');
                    const data = await response.json();
                    return data.map(kline => ({
                        time: kline[0],
                        open: parseFloat(kline[1]),
                        high: parseFloat(kline[2]),
                        low: parseFloat(kline[3]),
                        close: parseFloat(kline[4]),
                        volume: parseFloat(kline[5]),
                        closeTime: kline[6],
                        quoteVolume: parseFloat(kline[7])
                    }));
                } catch (error) {
                    console.error("Failed to fetch kline data via Render:", error);
                    return this.generateSimulatedKlineData(limit);
                }
            }

            // ============ SMART MONEY CONCEPTS IMPLEMENTATION ============
            analyzeMarketContext(klineData) {
                const closes = klineData.map(k => k.close);
                const ema50 = this.calculateEMA(closes, 50);
                const ema200 = this.calculateEMA(closes, 200);
                const currentPrice = closes[closes.length - 1];

                let context = 'ranging';
                let contextStrength = 0;

                if (currentPrice > ema50.fast && ema50.fast > ema200.slow) {
                    const ema50Angle = this.calculateEMAAngle(klineData, 50);
                    const ema200Angle = this.calculateEMAAngle(klineData, 200);
                    if (ema50Angle > 0.1 && ema200Angle > 0.05) {
                        context = 'uptrend';
                        contextStrength = Math.min(100, (ema50Angle * 1000) + (ema200Angle * 500));
                    }
                } else if (currentPrice < ema50.fast && ema50.fast < ema200.slow) {
                    const ema50Angle = this.calculateEMAAngle(klineData, 50);
                    const ema200Angle = this.calculateEMAAngle(klineData, 200);
                    if (ema50Angle < -0.1 && ema200Angle < -0.05) {
                        context = 'downtrend';
                        contextStrength = Math.min(100, Math.abs(ema50Angle * 1000) + Math.abs(ema200Angle * 500));
                    }
                }

                return { context, strength: contextStrength, ema50: ema50.fast, ema200: ema200.slow };
            }

            identifyOrderBlocks(klineData) {
                const blocks = [];
                for (let i = 2; i < klineData.length - 1; i++) {
                    const current = klineData[i];
                    const next = klineData[i + 1];
                    
                    if (current.close < current.open && next.close > next.open && 
                        Math.abs(next.close - next.open) > Math.abs(current.close - current.open) * 1.5) {
                        blocks.push({
                            type: 'bullish',
                            high: current.high,
                            low: current.low,
                            time: current.time,
                            strength: this.calculateBlockStrength(current, next)
                        });
                    } else if (current.close > current.open && next.close < next.open &&
                             Math.abs(next.close - next.open) > Math.abs(current.close - current.open) * 1.5) {
                        blocks.push({
                            type: 'bearish',
                            high: current.high,
                            low: current.low,
                            time: current.time,
                            strength: this.calculateBlockStrength(current, next)
                        });
                    }
                }
                return blocks.slice(-10);
            }

            identifyLiquidityPools(klineData) {
                const highs = klineData.map(k => k.high).slice(-50);
                const lows = klineData.map(k => k.low).slice(-50);
                const recentHigh = Math.max(...highs);
                const recentLow = Math.min(...lows);
                
                return {
                    above: recentHigh * 1.002,
                    below: recentLow * 0.998
                };
            }

            identifyFairValueGaps(klineData) {
                const gaps = [];
                for (let i = 1; i < klineData.length - 1; i++) {
                    const prev = klineData[i-1];
                    const curr = klineData[i];
                    const next = klineData[i+1];

                    if (prev.high < next.low) {
                        gaps.push({
                            type: 'bullish',
                            top: next.low,
                            bottom: prev.high,
                            time: curr.time
                        });
                    } else if (prev.low > next.high) {
                        gaps.push({
                            type: 'bearish',
                            top: prev.low,
                            bottom: next.high,
                            time: curr.time
                        });
                    }
                }
                return gaps.slice(-5);
            }

            detectMarketStructureShift(klineData) {
                if (klineData.length < 10) return false;
                const recent = klineData.slice(-8);
                const highs = recent.map(k => k.high);
                const lows = recent.map(k => k.low);
                const lastHigh = Math.max(...highs.slice(-4));
                const previousHigh = Math.max(...highs.slice(0, 4));
                const lastLow = Math.min(...lows.slice(-4));
                const previousLow = Math.min(...lows.slice(0, 4));

                return (lastHigh > previousHigh && lastLow > previousLow) || 
                       (lastHigh < previousHigh && lastLow < previousLow);
            }

            calculateBlockStrength(candle, nextCandle) {
                const blockSize = Math.abs(candle.high - candle.low);
                const moveSize = Math.abs(nextCandle.close - nextCandle.open);
                return Math.min(100, (moveSize / blockSize) * 50);
            }

            calculateEMAAngle(klineData, period) {
                if (klineData.length < period * 2) return 0;
                const closes = klineData.map(k => k.close);
                const currentEMA = this.calculateEMA(closes.slice(-period), period).fast;
                const previousEMA = this.calculateEMA(closes.slice(-period-10, -10), period).fast;
                return (currentEMA - previousEMA) / currentEMA;
            }

            async performSMCAnalysis(klineData) {
                const marketContext = this.analyzeMarketContext(klineData);
                const orderBlocks = this.identifyOrderBlocks(klineData);
                const liquidityPools = this.identifyLiquidityPools(klineData);
                const fairValueGaps = this.identifyFairValueGaps(klineData);
                const marketStructureShift = this.detectMarketStructureShift(klineData);

                const currentPrice = klineData[klineData.length - 1].close;
                const rsi = this.calculateRSI(klineData.map(k => k.close), 14);
                const macd = this.calculateMACD(klineData.map(k => k.close));

                let score = 0;
                let reasoning = [];
                let smcPatterns = [];

                const contextWeight = this.learningSystem.contextWeights[marketContext.context] || 1.0;

                orderBlocks.forEach(block => {
                    const distance = Math.abs(currentPrice - (block.high + block.low) / 2) / currentPrice;
                    if (distance < 0.02) {
                        const patternScore = block.strength * this.learningSystem.patternWeights.orderBlocks * contextWeight;
                        score += (block.type === 'bullish') ? patternScore : -patternScore;
                        reasoning.push(`${block.type.toUpperCase()} Order Block (${block.strength.toFixed(1)}%)`);
                        smcPatterns.push('orderblock');
                    }
                });

                const distanceToHighLiq = Math.abs(currentPrice - liquidityPools.above) / currentPrice;
                const distanceToLowLiq = Math.abs(currentPrice - liquidityPools.below) / currentPrice;
                
                if (distanceToHighLiq < 0.01) {
                    score -= 30 * this.learningSystem.patternWeights.liquidityPools;
                    reasoning.push("Near upper liquidity pool");
                    smcPatterns.push('liquidity_above');
                }
                if (distanceToLowLiq < 0.01) {
                    score += 30 * this.learningSystem.patternWeights.liquidityPools;
                    reasoning.push("Near lower liquidity pool");
                    smcPatterns.push('liquidity_below');
                }

                fairValueGaps.forEach(gap => {
                    if (currentPrice >= gap.bottom && currentPrice <= gap.top) {
                        const gapScore = 25 * this.learningSystem.patternWeights.fairValueGaps;
                        score += (gap.type === 'bullish') ? gapScore : -gapScore;
                        reasoning.push(`${gap.type.toUpperCase()} Fair Value Gap`);
                        smcPatterns.push('fvg');
                    }
                });

                if (marketStructureShift) {
                    score += 40 * this.learningSystem.patternWeights.marketStructure;
                    reasoning.push("Market Structure Shift detected");
                    smcPatterns.push('mss');
                }

                const rsiDivergence = this.detectRSIDivergence(klineData);
                if (rsiDivergence) {
                    const divergenceScore = 35 * this.learningSystem.patternWeights.rsiDivergence;
                    score += (rsiDivergence.type === 'bullish') ? divergenceScore : -divergenceScore;
                    reasoning.push(`${rsiDivergence.type.toUpperCase()} RSI Divergence`);
                    smcPatterns.push('rsi_divergence');
                }

                if ((marketContext.context === 'uptrend' && score > 0) || 
                    (marketContext.context === 'downtrend' && score < 0)) {
                    score *= 1.3;
                    reasoning.push(`Aligned with ${marketContext.context} context`);
                }

                return {
                    score,
                    reasoning,
                    smcPatterns: [...new Set(smcPatterns)],
                    marketContext,
                    orderBlocks: orderBlocks.slice(-3),
                    fairValueGaps: fairValueGaps.slice(-2),
                    liquidityPools,
                    rsi,
                    macd,
                    currentPrice
                };
            }

            detectRSIDivergence(klineData) {
                if (klineData.length < 20) return null;
                const closes = klineData.map(k => k.close);
                const rsiValues = this.calculateRSIValues(closes, 14);
                const recentCloses = closes.slice(-8);
                const recentRSI = rsiValues.slice(-8);

                const priceLowerLow = recentCloses[recentCloses.length-1] < recentCloses[recentCloses.length-3] &&
                                    recentCloses[recentCloses.length-3] < recentCloses[recentCloses.length-5];
                const rsiHigherLow = recentRSI[recentRSI.length-1] > recentRSI[recentRSI.length-3] &&
                                   recentRSI[recentRSI.length-3] > recentRSI[recentRSI.length-5];

                const priceHigherHigh = recentCloses[recentCloses.length-1] > recentCloses[recentCloses.length-3] &&
                                      recentCloses[recentCloses.length-3] > recentCloses[recentCloses.length-5];
                const rsiLowerHigh = recentRSI[recentRSI.length-1] < recentRSI[recentRSI.length-3] &&
                                   recentRSI[recentRSI.length-3] < recentRSI[recentRSI.length-5];

                if (priceLowerLow && rsiHigherLow) return { type: 'bullish', strength: 70 };
                if (priceHigherHigh && rsiLowerHigh) return { type: 'bearish', strength: 70 };
                
                return null;
            }

            calculateRSIValues(closes, period = 14) {
                if (closes.length < period + 1) return Array(closes.length).fill(50);
                
                const rsiValues = [];
                for (let i = period; i < closes.length; i++) {
                    const periodCloses = closes.slice(i - period, i);
                    let gains = 0;
                    let losses = 0;
                    
                    for (let j = 1; j < periodCloses.length; j++) {
                        const change = periodCloses[j] - periodCloses[j-1];
                        if (change > 0) gains += change;
                        else losses -= change;
                    }
                    
                    const avgGain = gains / period;
                    const avgLoss = losses / period;
                    const rs = avgGain / avgLoss;
                    rsiValues.push(100 - (100 / (1 + rs)));
                }
                
                return Array(period).fill(50).concat(rsiValues);
            }

            adaptiveLearnFromOutcome(predictionId, outcome) {
                const prediction = this.history.find(p => p.id === predictionId);
                if (!prediction) return;

                const isSuccess = outcome === 'Success';
                const smcPatterns = prediction.smcPatterns || [];

                smcPatterns.forEach(pattern => {
                    if (this.learningSystem.patternWeights[pattern]) {
                        if (isSuccess) {
                            this.learningSystem.patternWeights[pattern] = Math.min(2.0,
                                this.learningSystem.patternWeights[pattern] * (1 + 0.15));
                        } else {
                            this.learningSystem.patternWeights[pattern] = Math.max(0.8,
                                this.learningSystem.patternWeights[pattern] * (1 - 0.08));
                        }
                    }
                });

                const context = prediction.marketContext?.context;
                if (context && this.learningSystem.contextWeights[context]) {
                    if (isSuccess) {
                        this.learningSystem.contextWeights[context] = Math.min(1.5,
                            this.learningSystem.contextWeights[context] * (1 + 0.1));
                    } else {
                        this.learningSystem.contextWeights[context] = Math.max(0.7,
                            this.learningSystem.contextWeights[context] * (1 - 0.05));
                    }
                }

                this.learningSystem.successHistory.push({
                    timestamp: Date.now(),
                    success: isSuccess,
                    patterns: smcPatterns,
                    context: context
                });

                if (this.learningSystem.successHistory.length > 100) {
                    this.learningSystem.successHistory.shift();
                }

                console.log("Enhanced SMC Learning applied:", this.learningSystem.patternWeights);
            }

            async generatePredictions() {
                if (this.isAnalyzing) return;

                this.isAnalyzing = true;
                this.currentBatch++;

                const startBtn = document.getElementById('startBtn');
                startBtn.textContent = 'Running SMC Analysis...';
                startBtn.disabled = true;

                this.predictions = [];
                this.updatePredictionDisplay();

                try {
                    const klineData = await this.fetchKlineData(100);
                    const batchStartTime = this.binanceServerTime || Date.now();
                    const batchPredictions = [];

                    for (let i = 1; i <= 5; i++) {
                        this.updateProgress(i * 20);
                        await this.delay(500);

                        const prediction = await this.generateSMCPrediction(i, batchStartTime, klineData);
                        this.predictions.push(prediction);
                        batchPredictions.push(prediction);

                        this.updatePredictionDisplay();
                        this.updateSMCAnalysis();
                        this.updateRiskManagement();
                    }

                    this.batches.unshift({
                        id: batchStartTime,
                        timestamp: batchStartTime,
                        predictions: [...batchPredictions]
                    });

                    batchPredictions.forEach(pred => {
                        this.history.unshift(pred);
                    });

                    this.updateProgress(100);
                    this.updateHistory();
                    this.updatePerformance();
                    this.updateSignalStats();

                } catch (error) {
                    console.error("Prediction generation failed:", error);
                    this.showMessage("Error generating predictions. Using enhanced analysis.");
                }

                this.isAnalyzing = false;
                startBtn.textContent = 'Generate Smart Predictions';
                startBtn.disabled = false;
            }

            async generateSMCPrediction(sequenceNumber, batchStartTime, klineData) {
                const timeframeMs = this.getTimeframeMs(this.timeframe);
                const binanceTimestamp = batchStartTime + (sequenceNumber * timeframeMs);

                const analysis = await this.performSMCAnalysis(klineData);
                return this.createSMCPrediction(analysis, binanceTimestamp, sequenceNumber);
            }

            createSMCPrediction(analysis, binanceTimestamp, sequenceNumber) {
                const { score, reasoning, smcPatterns, marketContext, currentPrice } = analysis;

                let confidence = 50 + (score / 2);
                confidence = Math.min(95, Math.max(15, confidence));

                let predictionType = 'HOLD';
                if (confidence >= 65) predictionType = 'BUY';
                if (confidence <= 35) predictionType = 'SELL';

                const atr = this.calculateATR(analysis);
                const entry = currentPrice;
                let stopLoss, takeProfit, riskReward = 0;

                if (predictionType === 'BUY') {
                    stopLoss = Math.max(entry - atr * 1.2, entry * 0.985);
                    takeProfit = entry + (entry - stopLoss) * 2.0;
                    riskReward = 2.0;
                } else if (predictionType === 'SELL') {
                    stopLoss = Math.min(entry + atr * 1.2, entry * 1.015);
                    takeProfit = entry - (stopLoss - entry) * 2.0;
                    riskReward = 2.0;
                } else {
                    stopLoss = entry;
                    takeProfit = entry;
                }

                return {
                    id: binanceTimestamp + '-' + sequenceNumber,
                    binanceTimestamp: binanceTimestamp,
                    sequence: sequenceNumber,
                    timestamp: Date.now(),
                    symbol: this.symbol,
                    timeframe: this.timeframe,
                    type: predictionType,
                    entry: parseFloat(entry.toFixed(2)),
                    stop: parseFloat(stopLoss.toFixed(2)),
                    target: parseFloat(takeProfit.toFixed(2)),
                    riskReward: parseFloat(riskReward.toFixed(2)),
                    confidence: parseFloat(confidence.toFixed(1)),
                    reasoning: reasoning.slice(0, 3),
                    smcPatterns: smcPatterns,
                    marketContext: marketContext,
                    outcome: 'Active',
                    batch: this.currentBatch,
                    dataSource: this.isConnected ? 'Binance Live' : 'Simulated'
                };
            }

            calculateATR(analysis, period = 14) {
                return analysis.currentPrice * 0.02;
            }

            calculateRSI(closes, period = 14) {
                if (closes.length < period + 1) return 50;
                let gains = 0;
                let losses = 0;
                for (let i = 1; i <= period; i++) {
                    const change = closes[closes.length - i] - closes[closes.length - i - 1];
                    if (change > 0) gains += change;
                    else losses -= change;
                }
                const avgGain = gains / period;
                const avgLoss = losses / period;
                const rs = avgGain / avgLoss;
                return 100 - (100 / (1 + rs));
            }

            calculateMACD(closes, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
                const ema12 = this.calculateEMA(closes, fastPeriod);
                const ema26 = this.calculateEMA(closes, slowPeriod);
                const macdLine = ema12.fast - ema26.slow;
                const signalLine = macdLine * 0.8;
                const histogram = macdLine - signalLine;
                return { macdLine, signalLine, histogram };
            }

            calculateEMA(closes, period = 14) {
                const multiplier = 2 / (period + 1);
                let emaFast = closes[0];
                let emaSlow = closes[0];
                for (let i = 1; i < closes.length; i++) {
                    emaFast = (closes[i] - emaFast) * multiplier + emaFast;
                    emaSlow = (closes[i] - emaSlow) * (multiplier * 0.5) + emaSlow;
                }
                return { fast: emaFast, slow: emaSlow };
            }

            generateSimulatedKlineData(limit) {
                const data = [];
                let price = this.livePrice || 45000;
                for (let i = 0; i < limit; i++) {
                    const change = (Math.random() - 0.5) * 200;
                    price += change;
                    data.push({
                        time: Date.now() - (limit - i) * 60000,
                        open: price - change,
                        high: price + Math.random() * 100,
                        low: price - Math.random() * 100,
                        close: price,
                        volume: 800 + Math.random() * 800
                    });
                }
                return data;
            }

            startLiveUpdates() {
                setInterval(async () => {
                    try {
                        await this.fetchLivePrice();
                    } catch (error) {
                        console.log("Live update failed");
                    }
                }, 3000);
            }

            startSimulatedUpdates() {
                setInterval(() => {
                    const change = (Math.random() - 0.5) * 100;
                    this.livePrice += change;
                    this.priceChange = change;
                    this.updateLivePriceDisplay();
                }, 3000);
            }

            updateLivePriceDisplay() {
                const priceElement = document.getElementById('livePrice');
                const changeClass = this.priceChange >= 0 ? 'price-up' : 'price-down';
                const changeSymbol = this.priceChange >= 0 ? 'â†—' : 'â†˜';
                priceElement.innerHTML = `
                    ${this.symbol}: <span class="${changeClass}">$${this.livePrice.toFixed(2)}</span>
                    <span class="${changeClass}" style="font-size: 0.9rem; margin-left: 10px;">
                        ${changeSymbol} ${Math.abs(this.priceChange).toFixed(2)}
                    </span>
                `;
            }

            updateProgress(percent) {
                document.getElementById('analysisProgress').style.width = percent + '%';
                document.getElementById('progressText').textContent = `SMC Analysis progress: ${percent}%`;
            }

            recordOutcome(predictionId, outcome) {
                [this.predictions, this.history].forEach(collection => {
                    const pred = collection.find(p => p.id === predictionId);
                    if (pred) pred.outcome = outcome;
                });
                this.batches.forEach(batch => {
                    batch.predictions.forEach(p => {
                        if (p.id === predictionId) p.outcome = outcome;
                    });
                });
                this.adaptiveLearnFromOutcome(predictionId, outcome);
                this.updateHistory();
                this.updatePerformance();
                this.updatePredictionDisplay();
            }

            showMessage(message) {
                const analysisContainer = document.getElementById('analysisContainer');
                const existingContent = analysisContainer.innerHTML;
                analysisContainer.innerHTML = `
                    <div class="analysis-card" style="border-left: 4px solid #3b82f6">
                        <div class="analysis-header">
                            <span>System Update</span>
                            <span>âœ“</span>
                        </div>
                        <div>${message}</div>
                    </div>
                    ${existingContent}
                `;
            }

            setupEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => {
                    this.generatePredictions();
                });

                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.resetAnalysis();
                });

                document.getElementById('clearHistoryBtn').addEventListener('click', () => {
                    this.clearHistory();
                });

                document.getElementById('symbolSelect').addEventListener('change', (e) => {
                    this.symbol = e.target.value;
                    this.resetAnalysis();
                    this.fetchLivePrice();
                });

                document.getElementById('timeframeSelect').addEventListener('change', (e) => {
                    this.timeframe = e.target.value;
                    this.resetAnalysis();
                });

                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                        tab.classList.add('active');
                        document.getElementById(tab.dataset.tab + 'Tab').classList.add('active');
                    });
                });
            }

            resetAnalysis() {
                this.predictions = [];
                this.currentBatch = 0;
                this.updatePredictionDisplay();
                this.updateProgress(0);
                document.getElementById('signalStats').style.display = 'none';
                document.getElementById('startBtn').textContent = 'Generate Smart Predictions';
                document.getElementById('startBtn').disabled = false;
                document.getElementById('lastUpdate').textContent = 'SMC Analysis reset - ready for new predictions';
                this.showMessage("SMC Analysis reset - Advanced learning preserved");
            }

            clearHistory() {
                if (confirm("Clear all prediction history?")) {
                    this.history = [];
                    this.batches = [];
                    this.updateHistory();
                    this.updatePerformance();
                    this.showMessage("History cleared - SMC learning weights preserved");
                }
            }

            getTimeframeMs(timeframe) {
                const minute = 60 * 1000;
                switch(timeframe) {
                    case '1m': return minute;
                    case '5m': return 5 * minute;
                    case '15m': return 15 * minute;
                    case '1h': return 60 * minute;
                    case '4h': return 240 * minute;
                    default: return minute;
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            updateRiskManagement() {
                const container = document.getElementById('riskContent');
                if (this.predictions.length === 0) return;
                const lastPred = this.predictions[this.predictions.length - 1];
                if (lastPred.type === 'HOLD') {
                    container.innerHTML = `<p>No active trade - Market context unclear</p>`;
                    return;
                }
                const positionSize = Math.min(3, (1 + (lastPred.confidence - 50) / 50) * 1.5).toFixed(1);
                container.innerHTML = `
                    <div style="margin-bottom: 10px;"><strong>Position Size:</strong> ${positionSize}% of portfolio</div>
                    <div style="font-size: 0.8rem; color: #94a3b8; margin-bottom: 10px;">Based on ${lastPred.confidence}% SMC confidence</div>
                    <div style="margin-bottom: 10px;"><strong>Stop Loss:</strong> $${lastPred.stop}</div>
                    <div style="margin-bottom: 10px;"><strong>Take Profit:</strong> $${lastPred.target}</div>
                    <div style="margin-bottom: 10px;"><strong>Risk/Reward:</strong> 1:${lastPred.riskReward}</div>
                `;
            }

            updateSignalStats() {
                if (this.predictions.length === 0) return;
                const buyCount = this.predictions.filter(p => p.type === 'BUY').length;
                const sellCount = this.predictions.filter(p => p.type === 'SELL').length;
                const holdCount = this.predictions.filter(p => p.type === 'HOLD').length;
                document.getElementById('buyCount').textContent = buyCount;
                document.getElementById('sellCount').textContent = sellCount;
                document.getElementById('holdCount').textContent = holdCount;
                document.getElementById('signalStats').style.display = 'flex';
            }

            updateSMCAnalysis() {
                const container = document.getElementById('analysisContainer');
                const smcContainer = document.getElementById('smcContainer');

                if (this.predictions.length === 0) return;

                const lastPred = this.predictions[this.predictions.length - 1];
                const dataStatus = this.isConnected ? 'âœ… Live Binance Data' : 'âš ï¸ Simulated Data';

                container.innerHTML = `
                    <div class="analysis-card">
                        <div class="analysis-header">
                            <span>Market Context</span>
                            <span style="color: ${lastPred.marketContext.context === 'uptrend' ? '#10b981' : 
                                          lastPred.marketContext.context === 'downtrend' ? '#ef4444' : '#f59e0b'}">
                                ${lastPred.marketContext.context.toUpperCase()}
                            </span>
                        </div>
                        <div>Strength: ${lastPred.marketContext.strength.toFixed(1)}%</div>
                    </div>
                    <div class="analysis-card">
                        <div class="analysis-header">
                            <span>SMC Patterns Detected</span>
                            <span>${lastPred.smcPatterns.length}</span>
                        </div>
                        <div>${lastPred.smcPatterns.join(', ')}</div>
                    </div>
                    <div class="analysis-card">
                        <div class="analysis-header">
                            <span>AI Learning Status</span>
                            <span>ADVANCED âœ…</span>
                        </div>
                        <div>Pattern-based adaptive learning active</div>
                    </div>
                `;

                smcContainer.innerHTML = `
                    <div class="analysis-card">
                        <div class="analysis-header">
                            <span>Pattern Weights</span>
                            <span>Adaptive</span>
                        </div>
                        <div style="font-size: 0.8rem;">
                            ${Object.entries(this.learningSystem.patternWeights).map(([pattern, weight]) => 
                                `<div>${pattern}: ${weight.toFixed(2)}</div>`
                            ).join('')}
                        </div>
                    </div>
                    <div class="analysis-card">
                        <div class="analysis-header">
                            <span>Context Weights</span>
                            <span>Smart</span>
                        </div>
                        <div style="font-size: 0.8rem;">
                            ${Object.entries(this.learningSystem.contextWeights).map(([context, weight]) => 
                                `<div>${context}: ${weight.toFixed(2)}</div>`
                            ).join('')}
                        </div>
                    </div>
                `;
            }

            updateHistory() {
                const container = document.getElementById('historyContainer');
                if (this.batches.length === 0) {
                    container.innerHTML = `<div class="loading"><div class="pulse">No prediction history yet</div></div>`;
                    return;
                }
                container.innerHTML = this.batches.map(batch => {
                    const batchTime = new Date(batch.timestamp).toLocaleString();
                    return `
                        <div class="batch-group">
                            <div class="batch-header">
                                <div class="batch-title">Batch ${this.batches.indexOf(batch) + 1} â€¢ ${batchTime}</div>
                                <div class="batch-stats">${batch.predictions.length} predictions</div>
                            </div>
                            <div class="batch-predictions">
                                ${batch.predictions.map(pred => {
                                    const outcomeClass = pred.outcome === 'Success' ? 'status-success' :
                                        pred.outcome === 'Fail' ? 'status-fail' : 'status-active';
                                    return `
                                        <div class="prediction-card ${pred.type.toLowerCase()}">
                                            <div class="prediction-header">
                                                <div class="prediction-type ${pred.type.toLowerCase()}">${pred.type}</div>
                                                <div class="prediction-confidence">${pred.confidence}%</div>
                                            </div>
                                            <div class="prediction-price">$${pred.entry}</div>
                                            <div class="prediction-details">
                                                <div>Stop: $${pred.stop}</div>
                                                <div>Target: $${pred.target}</div>
                                            </div>
                                            <div class="prediction-timestamp">
                                                ${new Date(pred.binanceTimestamp).toLocaleTimeString()}
                                                <br><small>${pred.dataSource}</small>
                                            </div>
                                            <div class="prediction-reasoning">
                                                ${pred.reasoning[0]}
                                            </div>
                                            <div class="status-badge ${outcomeClass}" style="margin-top: 8px;">
                                                ${pred.outcome}
                                            </div>
                                            ${pred.outcome === 'Active' ? `
                                                <div class="prediction-actions">
                                                    <button class="btn btn-success" onclick="tradingAI.recordOutcome('${pred.id}', 'Success')">S</button>
                                                    <button class="btn btn-danger" onclick="tradingAI.recordOutcome('${pred.id}', 'Fail')">F</button>
                                                </div>
                                            ` : ''}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }).join('');
            }

            updatePerformance() {
                const container = document.getElementById('performanceContainer');
                const ratedPredictions = this.history.filter(p => p.outcome !== 'Active');
                const totalRated = ratedPredictions.length;
                const successCount = ratedPredictions.filter(p => p.outcome === 'Success').length;
                if (totalRated === 0) {
                    container.innerHTML = `<div class="loading"><div class="pulse">Rate predictions to see performance analytics</div></div>`;
                    return;
                }
                const successRate = ((successCount / totalRated) * 100).toFixed(1);
                container.innerHTML = `
                    <div class="analysis-card">
                        <div class="analysis-header"><span>SMC Success Rate</span><span>${successRate}%</span></div>
                        <div>Based on ${totalRated} rated predictions</div>
                    </div>
                    <div class="analysis-card">
                        <div class="analysis-header"><span>Performance</span><span>${successCount}W / ${totalRated - successCount}L</span></div>
                        <div>Advanced pattern learning active</div>
                    </div>
                `;
            }
        }

        // Initialize the ADVANCED trading AI
        let tradingAI = new AdvancedTradingAI();
    </script>
</body>
</html>
